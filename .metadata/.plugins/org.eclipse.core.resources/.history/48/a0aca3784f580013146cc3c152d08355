package menu;



import java.awt.Color;
import java.awt.Frame;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Point2D;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Calendar;

import javax.media.opengl.GL;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLCanvas;
import javax.media.opengl.GLCapabilities;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.glu.GLU;

import levelEditor.LevelEditor;

import com.sun.opengl.util.Animator;
import com.sun.opengl.util.texture.Texture;
import com.sun.opengl.util.texture.TextureData;
import com.sun.opengl.util.texture.TextureIO;

import engine.MazeRunner;
import engine.UserInput;



public class Main extends Frame implements GLEventListener, MouseListener, KeyListener, MouseMotionListener {
	static final long serialVersionUID = 7526471155622776147L;

	// Screen size.
	private int screenWidth = 800, screenHeight = 600;
	private float buttonSize = screenHeight / 10.0f;
	
	final byte MAINMENU = 0;
	final byte GAMEMENU = 1;
	final byte LEVELMENU = 2;
	final byte SETTINGS = 3;
	final byte QUIT = 4;
	final byte INGAME = 5;
	final byte LEVELEDITOR = 6;
	final byte PAUZE = 7;
	
	private boolean activate=false;
	
	private long previousTime = Calendar.getInstance().getTimeInMillis();
	// begintijd vastgesteld
	final private long startTime = Calendar.getInstance().getTimeInMillis();
	private long time;
	private long ingamepausetime;
	private long pausedtime;
	
	
	private int gamestate = MAINMENU;
	private int currentstate = gamestate;
	private boolean ingamestarted = false;
	
	//private long previousTime = Calendar.getInstance().getTimeInMillis();
	
	LevelEditor leveleditor; 
	MainMenu mainmenu;
	GameMenu gamemenu;
	LevelMenu levelmenu;
	Quit quit;
	Settings settings;
	UserInput userinput;
	MazeRunner mazerunner;
	
	// A GLCanvas is a component that can be added to a frame. The drawing
	// happens on this component.
	private GLCanvas canvas;
	
	GL gl;
	GLU glu;
	GLAutoDrawable drawable;
	

	public long getTime (){
		return time;
	}
	
	public long getNewTime () {
		
		return ingamepausetime;
	}
	
	/**
	 * The constructor of the window, in which all States can take place
	 */
	public Main() {
		super("naam van onze g@me");

	

		// Set the desired size and background color of the frame
		setSize(screenWidth, screenHeight);
		
		setBackground(new Color(0f, 0f, 0f));
		

		// When the "X" close button is called, the application should exit.
		this.addWindowListener(new WindowAdapter() {
			@Override
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}
		});

		// The OpenGL capabilities should be set before initializing the
		// GLCanvas. We use double buffering and hardware acceleration.
		GLCapabilities caps = new GLCapabilities();
		caps.setDoubleBuffered(true);
		caps.setHardwareAccelerated(true);

		// Create a GLCanvas with the specified capabilities and add it to this
		// frame. Now, we have a canvas to draw on using JOGL.
		canvas = new GLCanvas(caps);
		add(canvas);

		// Set the canvas' GL event listener to be this class. Doing so gives
		// this class control over what is rendered on the GL canvas.
		canvas.addGLEventListener(this);

		// Also add this class as mouse listener, allowing this class to react
		// to mouse events that happen inside the GLCanvas.
		canvas.addMouseListener(this);
		canvas.addMouseMotionListener(this);
		canvas.addKeyListener(this);

		// An Animator is a JOGL help class that can be used to make sure our
		// GLCanvas is continuously being re-rendered. The animator is run on a
		// separate thread from the main thread.
		Animator anim = new Animator(canvas);
		anim.start();

		// With everything set up, the frame can now be displayed to the user.
		setVisible(true);
	}

	@Override
	/**
	 * A function defined in GLEventListener. It is called once, when the frame containing the GLCanvas 
	 * becomes visible. In this assignment, there is no moving ´camera´, so the view and projection can 
	 * be set at initialization. 
	 */
	public void init(GLAutoDrawable drawable) {
		// Retrieve the OpenGL handle, this allows us to use OpenGL calls.
		//GL gl = drawable.getGL();
		gl = drawable.getGL();
		glu = new GLU();
		
	
		

		// Set the matrix mode to GL_PROJECTION, allowing us to manipulate the
		// projection matrix
		gl.glMatrixMode(GL.GL_PROJECTION);

		// Always reset the matrix before performing transformations, otherwise
		// those transformations will stack with previous transformations!
		gl.glLoadIdentity();

		mainmenu = new MainMenu(screenWidth, screenHeight);
		leveleditor = new LevelEditor(screenWidth, screenHeight);
		gamemenu = new GameMenu(screenWidth, screenHeight);
		quit = new Quit(screenWidth, screenHeight);
		settings = new Settings(screenWidth, screenHeight);
		levelmenu = new LevelMenu(screenWidth, screenHeight);
		
		userinput = new UserInput(canvas);
		mazerunner = new MazeRunner(screenWidth, screenHeight, canvas, drawable, gl, glu, userinput);
		
		
		/*
		 * glOrtho performs an "orthogonal projection" transformation on the
		 * active matrix. In this case, a simple 2D projection is performed,
		 * matching the viewing frustum to the screen size.
		 */
		gl.glOrtho(0, screenWidth, 0, screenHeight, -1, 1);

		// Set the matrix mode to GL_MODELVIEW, allowing us to manipulate the
		// model-view matrix.
		gl.glMatrixMode(GL.GL_MODELVIEW);

		// We leave the model view matrix as the identity matrix. As a result,
		// we view the world 'looking forward' from the origin.
		gl.glLoadIdentity();

		// We have a simple 2D application, so we do not need to check for depth
		// when rendering.
		gl.glDisable(GL.GL_DEPTH_TEST);
		
		
		
	}
	public void loadTextures(GL gl, String filename){
		gl.glEnable(GL.GL_TEXTURE_1D);
		Texture backTexture = null;
		try {
			String currentdir = System.getProperty("user.dir");
			//String filename = "EditorBackground.png";
			
			filename = currentdir+filename;
			File file = new File(filename);
			System.out.println(filename);
            //InputStream stream = getClass().getResourceAsStream("texture.jpg");
            TextureData data = TextureIO.newTextureData(file, false, "jpg");
            backTexture = TextureIO.newTexture(data);
        }
        catch (IOException exc) {
        	System.out.println("niet gevonden");
            exc.printStackTrace();
            System.exit(1);
        }
	}

	@Override
	/**
	 * A function defined in GLEventListener. This function is called many times per second and should 
	 * contain the rendering code.
	 */
	public void display(GLAutoDrawable drawable) {
		
		// over de tijd
		
		this.time = previousTime - startTime;
		
		
		// check of andere gamestate vanuit pauze wordt aangeroepen
		
		if (currentstate == INGAME && gamestate != INGAME){
			currentstate = gamestate;
			pausedtime=time;
		}
		
		if (currentstate != INGAME && gamestate == INGAME){
			// calculate the time elapsed while the game was paused
			ingamepausetime= time - ingamepausetime;
		}
		
		
		
		GL gl = drawable.getGL();

				
		// Set the clear color and clear the screen.
		gl.glClearColor(0f, 0f, 0f, 1f);
		gl.glClear(GL.GL_COLOR_BUFFER_BIT);
		
	
	switch(gamestate){
	case MAINMENU: 
		mainmenu.display(drawable, gl);
		
		
		break;
	case GAMEMENU:
		if (currentstate != gamestate){
			gamemenu.setScreen(screenWidth, screenHeight);
		}
		gamemenu.display(drawable, gl);
		currentstate = gamestate;
		break;
	case LEVELMENU:
		if (currentstate != gamestate){
			gamemenu.setScreen(screenWidth, screenHeight);
		}
		levelmenu.display(drawable, gl);
		currentstate = gamestate;
		
		break;
	case SETTINGS:
		settings.display(drawable, gl);
		
		break;
	case QUIT:
		quit.display(drawable, gl);
		
		break;
	case INGAME:
		if (!ingamestarted){
			ingamestarted =true;
			// hier alle inits voor de mazerunner	
			mazerunner.init(drawable, gl, glu);
			//mazerunner.initObjects(canvas, userinput);
			
		}
		if (currentstate != gamestate){
			mazerunner.setScreen(glu, gl, screenWidth, screenHeight);
			
		}
		mazerunner.display(drawable, gl);
		
		break;
	case LEVELEDITOR:
		
		if (currentstate != gamestate){
			leveleditor=new LevelEditor(screenWidth, screenHeight);	
		}
		leveleditor.display(gl);
		currentstate = gamestate;
		break;
	case PAUZE:
		
		break;
	}
		
	
		gl.glFlush();
	}

	
	public void tekenMenuAchtergrond(GL gl){
		
		
	}

	public void displayChanged(GLAutoDrawable drawable, boolean modeChanged,
			boolean deviceChanged) {
		// Not needed.
	}

	@Override
	/**
	 * A function defined in GLEventListener. This function is called when the GLCanvas is resized or moved. 
	 * Since the canvas fills the frame, this event also triggers whenever the frame is resized or moved.
	 */
	public void reshape(GLAutoDrawable drawable, int x, int y, int width,
			int height) {
		GL gl = drawable.getGL();
		
		// Set the new screen size and adjusting the viewport
		screenWidth = width;
		screenHeight = height;
		buttonSize = height / 10.0f;
		gl.glViewport(0, 0, screenWidth, screenHeight);
		userinput.reshape();
		
		switch(gamestate){
		case MAINMENU: 
			mainmenu.setScreen(screenWidth, screenHeight);
			
			break;
		case GAMEMENU:
			
			break;
		case LEVELMENU:
			
			break;
		case SETTINGS:
			
			break;
		case QUIT:
			
			break;
		case INGAME:
			
			break;
		case LEVELEDITOR:
		
			leveleditor.setScreen(screenWidth, screenHeight);

			break;
		case PAUZE:
			
			break;
		}

		// Update the projection to an orthogonal projection using the new screen size
		gl.glMatrixMode(GL.GL_PROJECTION);
		gl.glLoadIdentity();
		gl.glOrtho(0, screenWidth, 0, screenHeight, -1, 1);
	}

	
	/**
	 * A function defined in MouseListener. Is called when the pointer is in the GLCanvas, and a mouse button is released.
	 */
	public void mouseReleased(MouseEvent me) {
		
		//GL gl = drawable.getGL();
		
		
		switch(gamestate){
		case MAINMENU: 
			mainmenu.setScreen(screenWidth, screenHeight);
			gamestate = mainmenu.mouseReleased(me);
			gamestate = INGAME;
			System.out.println(gamestate);
			break;
		case GAMEMENU:
			
			break;
		case LEVELMENU:
			
			break;
		case SETTINGS:
			
			break;
		case QUIT:
			
			break;
		case INGAME:
			
			break;
		case LEVELEDITOR:
			
			leveleditor.mouseReleased(me);
			
			break;
		case PAUZE:
			
			break;
		}
	}

	@Override
	public void mouseClicked(MouseEvent arg0) {
		switch(gamestate){
		case MAINMENU: 
			
			break;
		case GAMEMENU:
			
			break;
		case LEVELMENU:
			
			break;
		case SETTINGS:
			
			break;
		case QUIT:
			
			break;
		case INGAME:
			
			break;
		case LEVELEDITOR:

			break;
		case PAUZE:
			
			break;
		}
	}

	@Override
	public void mouseEntered(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseExited(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mousePressed(MouseEvent e) {
		switch(gamestate){
		case MAINMENU: 
			
			break;
		case GAMEMENU:
			
			break;
		case LEVELMENU:
			
			break;
		case SETTINGS:
			
			break;
		case QUIT:
			
			break;
		case INGAME:
			
			userinput.mousePressed(e);
			
			break;
		case LEVELEDITOR:

			break;
		case PAUZE:
			
			break;
		}
		
	}
	
	public static void main (String[] args){
		new Main();
	}

	@Override
	public void mouseDragged(MouseEvent e) {
		if (gamestate == INGAME){
			userinput.mouseDragged(e);
		}
		
	}

	@Override
	public void mouseMoved(MouseEvent e) {
		if (gamestate == INGAME){
			userinput.mouseMoved(e);
	}
	}

	@Override
	public void keyPressed(KeyEvent e) {
		if (gamestate == INGAME){
			//System.out.println("yeah");
			userinput.keyPressed(e);
			
			
		}
	}

	@Override
	public void keyReleased(KeyEvent e) {
		if (gamestate == INGAME){
			userinput.keyReleased(e);
			System.out.println("yo");
	}
	}

	@Override
	public void keyTyped(KeyEvent arg0) {
		// TODO Auto-generated method stub
		
	}
}