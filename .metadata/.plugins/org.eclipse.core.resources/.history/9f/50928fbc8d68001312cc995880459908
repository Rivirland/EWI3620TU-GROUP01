package engine;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class GeneticAlgorithm {
	private ArrayList<Maze> mazes;
	public int parentsPerIteration;

	public GeneticAlgorithm(ArrayList<Maze> mazelist, int ppi) {
		mazes = mazelist;
		parentsPerIteration = ppi;
	}

	public void assignPortalID() {
		int i = 0;
		for (Portal p : MazeRunner.portalList) {
			p.setPortalID(i);
			i++;
		}
	}

	public void connectPortals() {

	}

	public void solve() {
		double[][] distanceMatrix = calcDistances();
		

	}
	

	public int[][] iterate(int[][] parents, int iteration){
		//Saves all the new parents into the results matrix
		int[][] results = new int[parentsPerIteration * 2][size-2];
		for(int row = 0; row < parentsPerIteration; row++){
			results[row] = parents[row];
		}
		
		//Generates random children and puts them into results
		for(int row = 0; row < parentsPerIteration/2; row++){
			int p1 = (int) (parentsPerIteration * Math.random());
			int p2 = (int) (parentsPerIteration * Math.random());
			results[parentsPerIteration + row] = GeneticAlgorithms.mutation(GeneticAlgorithms.crossover(parents[p1], parents[p2]));
			results[parentsPerIteration + row + parentsPerIteration/2] = GeneticAlgorithms.mutation(GeneticAlgorithms.crossover(parents[p2], parents[p1]));
		}
		
		//sorts the parents and children in results on length and selects the new parents
		//by storing the parentsPerIteration fittest chromosomes in a new matrix
		int[] lengths = new int[2*parentsPerIteration];
		for(int row = 0; row < results.length; row++){
			lengths[row] = calcDistance(results[row]);
		}
		int[] sorted = (int[]) lengths.clone();
		Arrays.sort(sorted);
		
		int[][] newParents = new int[parentsPerIteration][size];
		for(int i = 0; i < parentsPerIteration; i++){
			for (int j = 0; j < lengths.length; j++){
				if(sorted[i] == lengths[j]){
					newParents[i] = results[j];
				}
			}
		}
		
		//Checks if a new global optimum has been found
		int minLength = Integer.MAX_VALUE;
		int length = this.calcDistance(newParents[0]);
		if(length < minLength){
			minLength = length;
//			System.out.println("i: " + iteration + ", l: " + length);
		}
//		System.out.print(this.calcDistance(newParents[0]) + ",");
		
		return newParents;
	}
	//Generates random parents
	private int[][] generateParents(){
		int parentsPerIteration = 50;
		int[][] parents = new int[parentsPerIteration][mazes.size()];
		for (int i = 0; i < parentsPerIteration; i++){
			List<Integer> data = new ArrayList<Integer>();
			for(int j = 0; j < mazes.size(); j++){
				data.add(j + 1);
			}
			Collections.shuffle(data);
			int[] num = new int[data.size()];
			for (int j = 0; j < data.size(); j++){
				num[j] = data.get(j);
			}
			parents[i] = num;
		}
		return parents;
	}

	private double[][] calcDistances() {
		double[][] res = new double[mazes.size()][mazes.size()];
		for (int i = 0; i < mazes.size(); i++) {
			for (int j = 0; j <= i; j++) {
				if (j == i) {
					res[i][j] = 0;
				} else {
					double distance = Integer.MAX_VALUE;
					for (int x = 0; x < 2; x++) {
						for (int y = 0; y < 2; y++) {
							float dX = MazeRunner.portalList.get(i * 2 + x).getX() - MazeRunner.portalList.get(j * 2 + y).getX();
							float dZ = MazeRunner.portalList.get(i * 2 + x).getZ() - MazeRunner.portalList.get(j * 2 + y).getZ();
							if (Math.sqrt(dX * dX + dZ * dZ) < distance) {
								distance = Math.sqrt(dX * dX + dZ * dZ);
							}
						}
					}
					res[i][j] = distance;
					res[j][i] = distance;
				}
			}
		}
		return res;
	}

}
