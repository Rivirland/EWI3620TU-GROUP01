package engine;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class GeneticAlgorithm {
	private ArrayList<Maze> mazes;

	public GeneticAlgorithm(ArrayList<Maze> mazelist) {
		mazes = mazelist;
	}

	public void assignPortalID() {
		int i = 0;
		for (Portal p : MazeRunner.portalList) {
			p.setPortalID(i);
			i++;
		}
	}

	public void connectPortals() {

	}

	public void solve() {
		double[][] distanceMatrix = calcDistances();
		

	}
	
	//Generates random parents
	private int[][] generateParents(){
		int parentsPerIteration = 50;
		int[][] parents = new int[parentsPerIteration][mazes.size()];
		for (int i = 0; i < parentsPerIteration; i++){
			List<Integer> data = new ArrayList<Integer>();
			for(int j = 0; j < size-2; j++){
				data.add(j + 1);
			}
			Collections.shuffle(data);
			int[] num = new int[data.size()];
			for (int j = 0; j < data.size(); j++){
				num[j] = data.get(j);
			}
			parents[i] = num;
		}
		return parents;
	}

	private double[][] calcDistances() {
		double[][] res = new double[mazes.size()][mazes.size()];
		for (int i = 0; i < mazes.size(); i++) {
			for (int j = 0; j <= i; j++) {
				if (j == i) {
					res[i][j] = 0;
				} else {
					double distance = Integer.MAX_VALUE;
					for (int x = 0; x < 2; x++) {
						for (int y = 0; y < 2; y++) {
							float dX = MazeRunner.portalList.get(i * 2 + x).getX() - MazeRunner.portalList.get(j * 2 + y).getX();
							float dZ = MazeRunner.portalList.get(i * 2 + x).getZ() - MazeRunner.portalList.get(j * 2 + y).getZ();
							if (Math.sqrt(dX * dX + dZ * dZ) < distance) {
								distance = Math.sqrt(dX * dX + dZ * dZ);
							}
						}
					}
					res[i][j] = distance;
					res[j][i] = distance;
				}
			}
		}
		return res;
	}

}
